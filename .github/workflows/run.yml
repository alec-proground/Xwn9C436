name: Extract Extension Info

on:
  issues:
    types: [opened]

jobs:
  extract:
    runs-on: ubuntu-latest
    outputs:
      extension_name: ${{ steps.parse.outputs.extension_name }}
      version: ${{ steps.parse.outputs.version }}
    steps:
      - name: Parse Issue Body
        id: parse
        run: |
          ISSUE_BODY="${{ github.event.issue.body }}"

          get_form_value() {
            local header="### $1"
            echo "$ISSUE_BODY" | awk -v header="$header" '
              $0 == header {
                getline
                while ($0 ~ /^\s*$/) { getline }
                print $0
                exit
              }' | xargs
          }

          EXTENSION_NAME=$(get_form_value "Publsher & Extension Name")
          VERSION=$(get_form_value "version")

          echo "Extension Name: $EXTENSION_NAME"
          echo "Version: $VERSION"

          echo "extension_name=$EXTENSION_NAME" >> $GITHUB_OUTPUT
          echo "version=$VERSION" >> $GITHUB_OUTPUT

  search:
    needs: extract
    runs-on: ubuntu-latest
    outputs:
      publisher: ${{ steps.search-step.outputs.publisher }}
      title: ${{ steps.search-step.outputs.title }}
      description: ${{ steps.search-step.outputs.description }}
      extension_released: ${{ steps.search-step.outputs.extension_released }}
      version: ${{ steps.search-step.outputs.version }}
      version_updated: ${{ steps.search-step.outputs.version_updated }}
      vsix_url: ${{ steps.search-step.outputs.vsix_url }}
      signature_url: ${{ steps.search-step.outputs.signature_url }}
      message: ${{ steps.search-step.outputs.message }}
    steps:
      - name: Search Marketplace
        id: search-step
        uses: actions/github-script@v7
        with:
          script: |
            const keyword = "${{ needs.extract.outputs.extension_name }}".trim();
            const [publisher, extensionName] = keyword.split('.')
            const versionOnForm = "${{ needs.extract.outputs.version }}";
            const version = versionOnForm === "_No response_" ? "" : versionOnForm.trim();

            core.setOutput('publisher', publisher);
            core.setOutput('title', extensionName);
            core.setOutput('version', version);

            try {
              if (!publisher || !extensionName ) {
                throw new Error('Extension Name is missing from the extract step.');
              }

              const url = "https://marketplace.visualstudio.com/_apis/public/gallery/extensionquery";
              const body = {
                filters: [{
                  criteria: [{
                    filterType: 7,
                    value: `${publisher}.${extensionName}`
                  }],
                  pageNumber: 1,
                  pageSize: 1,
                  sortBy: 0,
                  sortOrder: 0
                }],
                assetTypes: [],
                flags: 1459
              };

              const response = await fetch(url, {
                method: 'POST',
                headers: {
                  'Accept': 'application/json;api-version=3.0-preview.1',
                  'Content-Type': 'application/json'
                },
                body: JSON.stringify(body)
              });

              if (!response.ok) {
                throw new Error(`Failed to query marketplace: ${response.status} ${response.statusText}`);
              }

              const data = await response.json();
              if (!data.results || !data.results[0] || !data.results[0].extensions) {
                throw new Error(`Error: Invalid response structure from marketplace.`);
              }
              const extensions = data.results[0].extensions;
              if (extensions.length !== 1) {
                throw new Error(`Error: Expected 1 extension in response, but found ${extensions.length}.`);
              }

              const extension = extensions[0];
              if (extension.publisher.publisherName.toLowerCase() !== publisher.toLowerCase()) {
                throw new Error(`Error: Publisher name mismatch. Expected '${publisher}' (case-insensitive), but found '${extension.publisher.publisherName}'.`);
              }

              if (extension.extensionName.toLowerCase() !== extensionName.toLowerCase()) {
                throw new Error(`Error: Extension name mismatch. Expected '${extensionName}' (case-insensitive), but found '${extension.extensionName}'.`);
              }
              core.info('✔️ Extension name matches.');

              if (!extension.versions || extension.versions.length === 0) {
                throw new Error(`Error: No versions found for this extension.`);
              }

              if (version) {
                core.info(`ℹ️ Specific version requested: ${version}`);
                const versionExists = extension.versions.some(v => v.version === version);
                if (!versionExists) {
                  throw new Error(`Error: Specified version '${version}' not found in the marketplace.`);
                }
                core.info(`✔️ Specified version '${version}' found.`);
              } else {
                core.info('ℹ️ No specific version requested, skipping version check.');
              }

              // --- Extract Asset URLs ---
              let targetVersionStr = version || extension.versions[0].version;
              const targetVersion = extension.versions.find(v => v.version === targetVersionStr);
              if (!targetVersion) {
                throw new Error(`Error: Could not find metadata for target version ${targetVersionStr}.`);
              }

              const vsixFile = targetVersion.files.find(f => f.assetType === 'Microsoft.VisualStudio.Services.VSIXPackage');
              const signatureFile = targetVersion.files.find(f => f.assetType === 'Microsoft.VisualStudio.Services.VsixSignature');

              if (!vsixFile || !signatureFile) {
                throw new Error(`Could not find VSIX or Signature URL for version ${targetVersionStr}.`);
              }

              const vsixUrl = vsixFile.source;
              const signatureUrl = signatureFile.source;

              core.info(`Publisher: ${publisher}`);
              core.info(`Extension: ${extensionName}`);
              core.info(`VSIX URL: ${vsixUrl}`);
              core.info(`Signature URL: ${signatureUrl}`);
              core.info(`ShortDescription: ${extension.shortDescription}`);
              core.info(`ReleaseDate URL: ${extension.releaseDate}`);
              core.info(`Version: ${targetVersion.version}`);
              core.info(`LastUpdate: ${targetVersion.lastUpdated}`);
              
              core.setOutput('description', extension.shortDescription);
              core.setOutput('extension_released', extension.releaseDate);
              core.setOutput('version_updated', targetVersion.lastUpdated);
              core.setOutput('vsix_url', vsixUrl);
              core.setOutput('signature_url', signatureUrl);
            } catch (error) {
              core.setOutput('message', error.message);
              core.setFailed(error.message);
              return;
            }

  execute-ssm-install:
    needs: search
    if: success()
    runs-on: ubuntu-latest
    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Execute SSM Document
        env:
          DOCUMENT_NAME: "manage-marketplace-extensions"
          INSTANCE_ID: ${{ secrets.INSTANCE_ID }}
          URL: ${{ needs.search.outputs.vsix_url }}
        run: |
          aws ssm send-command \
            --document-name ${{ env.DOCUMENT_NAME }} \
            --targets "Key=instanceids,Values=${{ env.INSTANCE_ID }}" \
            --parameters '{"url":["${{ env.URL }}"]}' \
            --region ${{ secrets.AWS_REGION }}

  update-issue:
    needs: [execute-ssm-install,search]
    if: success()
    runs-on: ubuntu-latest
    permissions:
      issues: write
    steps:
      - name: Add VSIX URL comment to issue
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const vsixUrl = "${{ needs.search.outputs.vsix_url }}";
            const commentBody = [              
              "# ${{ needs.search.outputs.publisher }}.${{ needs.search.outputs.title }}:${{ needs.search.outputs.version }}",
              "${{ needs.search.outputs.description }}",
              "- Initial release: ${{ needs.search.outputs.extension_released }}",
              "- Last Update for this version: ${{ needs.search.outputs.version_updated }}",
              "- Bundle URL: ${{ needs.search.outputs.vsix_url }}",
              "- Signature URL: ${{ needs.search.outputs.signature_url }}",
            ];
            
            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: commentBody.join('\n')
            });
            const new_title = `[COMPLETED] ${{ needs.search.outputs.title }}:${{ needs.search.outputs.version }}`
            await github.rest.issues.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              title: new_title,
              state: 'closed'
            });
            console.log(`Commented on issue #${context.issue.number}`);
            
  report-failure:
    needs: search
    if: failure()
    runs-on: ubuntu-latest
    permissions:
      issues: write
    steps:
      - name: Report failure to issue
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const failureMsg = "${{ needs.search.outputs.message }}" || 'Unknown Error';
            const issueTitle = `[FAILED] ${{ needs.search.outputs.title }}:${{ needs.search.outputs.version }} - ${ failureMsg }`;
            await github.rest.issues.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              title: issueTitle,
              state: 'closed',
              state_reason: 'not_planned'
            });

            const commentBody = [
             `# Failed to process the extension request.`,
             `Please check the workflow run logs for details.`,
             `- Action: https://github.com/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.payload.workflow_run.id}`,
            ].join('\n');
            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: commentBody
            });


