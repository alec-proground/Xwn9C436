name: Extract Extension Info

on:
  issues:
    types: [opened]

jobs:
  extract:
    runs-on: ubuntu-latest
    outputs:
      extension_name: ${{ steps.parse.outputs.extension_name }}
      version: ${{ steps.parse.outputs.version }}
    steps:
      - name: Parse Issue Body
        id: parse
        run: |
          ISSUE_BODY="${{ github.event.issue.body }}"

          get_form_value() {
            local header="### $1"
            echo "$ISSUE_BODY" | awk -v header="$header" '
              $0 == header {
                getline
                while ($0 ~ /^\s*$/) { getline }
                print $0
                exit
              }' | xargs
          }

          EXTENSION_NAME=$(get_form_value "Publsher & Extension Name")
          VERSION=$(get_form_value "version")

          echo "Extension Name: $EXTENSION_NAME"
          echo "Version: $VERSION"

          echo "extension_name=$EXTENSION_NAME" >> $GITHUB_OUTPUT
          echo "version=$VERSION" >> $GITHUB_OUTPUT

  search:
    needs: extract
    runs-on: ubuntu-latest
    outputs:
      publisher: ${{ steps.search-step.outputs.publisher }}
      title: ${{ steps.search-step.outputs.title }}
      description: ${{ steps.search-step.outputs.description }}
      extension_released: ${{ steps.search-step.outputs.extension_released }}
      version: ${{ steps.search-step.outputs.version }}
      version_updated: ${{ steps.search-step.outputs.version_updated }}
      vsix_url: ${{ steps.search-step.outputs.vsix_url }}
      signature_url: ${{ steps.search-step.outputs.signature_url }}
      message: ${{ steps.search-step.outputs.message }}
    steps:
      - name: Search Marketplace
        id: search-step
        uses: actions/github-script@v7
        with:
          script: |
            const keyword = "${{ needs.extract.outputs.extension_name }}".trim();
            const [publisher, extensionName] = keyword.split('.')
            const versionOnForm = "${{ needs.extract.outputs.version }}";
            const version = versionOnForm === "_No response_" ? "" : versionOnForm.trim();

            core.setOutput('publisher', publisher);
            core.setOutput('title', extensionName);
            core.setOutput('version', version);


            if (!publisher || !extensionName ) {
              core.setFailed('Extension Name is missing from the extract step.');
              return;
            }

            core.info(`üì° Querying marketplace for ${publisher}`);

            const url = "https://marketplace.visualstudio.com/_apis/public/gallery/extensionquery";
            const body = {
              filters: [{
                criteria: [{
                  filterType: 7,
                  value: `${publisher}.${extensionName}`
                }],
                pageNumber: 1,
                pageSize: 1,
                sortBy: 0,
                sortOrder: 0
              }],
              assetTypes: [],
              flags: 1459
            };

            const response = await fetch(url, {
              method: 'POST',
              headers: {
                'Accept': 'application/json;api-version=3.0-preview.1',
                'Content-Type': 'application/json'
              },
              body: JSON.stringify(body)
            });

            if (!response.ok) {
              const message = `Failed to query marketplace: ${response.status} ${response.statusText}`
              core.setOutput('message', message);
              core.setFailed(message);
              return;
            }

            const data = await response.json();

            // --- Validation Steps ---
            core.info('üßê Validating response...');
            if (!data.results || !data.results[0] || !data.results[0].extensions) {
              const message = `Error: Invalid response structure from marketplace.`;
              core.setOutput('message', message);
              core.setFailed(message);
              return;
            }
            const extensions = data.results[0].extensions;
            if (extensions.length !== 1) {
              const message = `Error: Expected 1 extension in response, but found ${extensions.length}.`;
              core.setOutput('message', message);
              core.setFailed(message);
              return;
            }
            core.info('‚úîÔ∏è Found exactly one extension.');

            const extension = extensions[0];
            if (extension.publisher.publisherName.toLowerCase() !== publisher.toLowerCase()) {
              const message = `Error: Publisher name mismatch. Expected '${publisher}' (case-insensitive), but found '${extension.publisher.publisherName}'.`;
              core.setOutput('message', message);
              core.setFailed(message);
              return;
            }
            core.info('‚úîÔ∏è Publisher name matches.');

            if (extension.extensionName.toLowerCase() !== extensionName.toLowerCase()) {
              const message = `Error: Extension name mismatch. Expected '${extensionName}' (case-insensitive), but found '${extension.extensionName}'.`;
              core.setOutput('message', message);
              core.setFailed(message);
              return;
            }
            core.info('‚úîÔ∏è Extension name matches.');

            if (!extension.versions || extension.versions.length === 0) {
              const message = `Error: No versions found for this extension.`;
              core.setOutput('message', message);
              core.setFailed(message);
              return;
            }
            core.info(`‚úîÔ∏è Found ${extension.versions.length} version(s).`);

            if (version) {
              core.info(`‚ÑπÔ∏è Specific version requested: ${version}`);
              const versionExists = extension.versions.some(v => v.version === version);
              if (!versionExists) {
                const message = `Error: Specified version '${version}' not found in the marketplace.`;
                core.setOutput('message', message);
                core.setFailed(message);
                return;
              }
              core.info(`‚úîÔ∏è Specified version '${version}' found.`);
            } else {
              core.info('‚ÑπÔ∏è No specific version requested, skipping version check.');
            }

            core.info('‚úÖ Validation successful.');

            // --- Extract Asset URLs ---
            let targetVersionStr = version || extension.versions[0].version;
            core.info(`‚ÑπÔ∏è Using version for asset download: ${targetVersionStr}`);

            const targetVersion = extension.versions.find(v => v.version === targetVersionStr);
            if (!targetVersion) {
              const message = `Error: Could not find metadata for target version ${targetVersionStr}.`;
              core.setOutput('message', message);
              core.setFailed(message);
              return;
            }

            const vsixFile = targetVersion.files.find(f => f.assetType === 'Microsoft.VisualStudio.Services.VSIXPackage');
            const signatureFile = targetVersion.files.find(f => f.assetType === 'Microsoft.VisualStudio.Services.VsixSignature');

            if (!vsixFile || !signatureFile) {
              const message = `Could not find VSIX or Signature URL for version ${targetVersionStr}.`;
              core.setOutput('message', message);
              core.setFailed(message);
              return;
            }

            const vsixUrl = vsixFile.source;
            const signatureUrl = signatureFile.source;

            core.info(`Publisher: ${publisher}`);
            core.info(`Extension: ${extensionName}`);
            core.info(`VSIX URL: ${vsixUrl}`);
            core.info(`Signature URL: ${signatureUrl}`);
            core.info(`ShortDescription: ${extension.shortDescription}`);
            core.info(`ReleaseDate URL: ${extension.releaseDate}`);
            core.info(`Version: ${targetVersion.version}`);
            core.info(`LastUpdate: ${targetVersion.lastUpdated}`);
            
            core.setOutput('description', extension.shortDescription);
            core.setOutput('extension_released', extension.releaseDate);
            core.setOutput('version_updated', targetVersion.lastUpdated);
            core.setOutput('vsix_url', vsixUrl);
            core.setOutput('signature_url', signatureUrl);

  execute-ssm-install:
    needs: search
    if: success()
    runs-on: ubuntu-latest
    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Execute SSM Document
        env:
          DOCUMENT_NAME: "manage-marketplace-extensions"
          INSTANCE_ID: ${{ secrets.INSTANCE_ID }}
          URL: ${{ needs.search.outputs.vsix_url }}
        run: |
          aws ssm send-command \
            --document-name ${{ env.DOCUMENT_NAME }} \
            --targets "Key=instanceids,Values=${{ env.INSTANCE_ID }}" \
            --parameters '{"url":["${{ env.URL }}"]}' \
            --region ${{ secrets.AWS_REGION }}

  update-issue:
    needs: [execute-ssm-install,search]
    if: success()
    runs-on: ubuntu-latest
    permissions:
      issues: write
    steps:
      - name: Add VSIX URL comment to issue
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const vsixUrl = "${{ needs.search.outputs.vsix_url }}";
            const commentBody = [              
              "publisher: ${{ needs.search.outputs.publisher }}",
              "title: ${{ needs.search.outputs.title }}",
              "description: ${{ needs.search.outputs.description }}",
              "extension_released: ${{ needs.search.outputs.extension_released }}",
              "version: ${{ needs.search.outputs.version }}",
              "version_updated: ${{ needs.search.outputs.version_updated }}",
              "vsix_url: ${{ needs.search.outputs.vsix_url }}",
              "signature_url: ${{ needs.search.outputs.signature_url }}",
            ];
            
            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: commentBody.join('\n')
            });
            const new_title = `[COMPLETED] ${{ needs.search.outputs.title }}:${{ needs.search.outputs.version }}`
            await github.rest.issues.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              title: new_title,
              state: 'closed'
            });
            console.log(`Commented on issue #${context.issue.number}`);
            
  report-failure:
    needs: search
    if: failure()
    runs-on: ubuntu-latest
    permissions:
      issues: write
    steps:
      - name: Report failure to issue
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const commentBody = `‚ùå Failed to process the extension request. Please check the workflow run logs for details.`;
            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: commentBody
            });

            const issueTitle = `[FAILED] ${{ needs.search.outputs.title }}:${{ needs.search.outputs.version }} - ${{ needs.search.outputs.message }}`;
            
            await github.rest.issues.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              title: issueTitle,
              state: 'closed',
              state_reason: 'not_planned'
            });

